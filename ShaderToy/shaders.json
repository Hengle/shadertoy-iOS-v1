[{
	"name" : "Blobs",
	"date" : "15/2/2013",
	"description" : "Color blobs using 1/length for color value, changing makePoint function can give very cool results ;)",
	"author" : "PauloFalcao",
	"authorProfile" : "https://www.shadertoy.com/user/PauloFalcao",
	"shaderLink" : "https://www.shadertoy.com/view/lsfGzr",
	"tags" : ["2d", "blobs"],
	"views" : 428,
	"likes" : 9,
	"comments" : [{
			"author" : "Cha",
			"date" : "15/2/2013",
			"comment" : "Love it!!",
			"pictureURL" : "https://www.shadertoy.com/users/Cha/profile.jpeg"
		},
		{
			"author" : "Mipmap",
			"date" : "26/2/2013",
			"comment" : "Love the simplicity and glow effect.",
			"pictureURL" : "https://www.shadertoy.com/img/profile.jpg"
		},
		{
			"author" : "huttarl",
			"date" : "14/3/2013",
			"comment" : "Ditto! Simple enough that even I can understand it.",
			"pictureURL" : "https://www.shadertoy.com/users/huttarl/profile.jpeg"
		},
		{
			"author" : "huttarl",
			"date" : "14/3/2013",
			"comment" : "I like how every n seconds, the even ones coalesce at the bottom and the odd ones at the top. And every 2n seconds, they all meet at the bottom.",
			"pictureURL" : "https://www.shadertoy.com/users/huttarl/profile.jpeg"
		}
	],
	"shaderString" : "// Blobs by @paulofalcao

float time=iGlobalTime;

float makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){
   float xx=x+sin(t*fx)*sx;
   float yy=y+cos(t*fy)*sy;
   return 1.0/sqrt(xx*xx+yy*yy);
}

void main( void ) {

   vec2 p=(gl_FragCoord.xy/iResolution.x)*2.0-vec2(1.0,iResolution.y/iResolution.x);

   p=p*2.0;
   
   float x=p.x;
   float y=p.y;

   float a=
       makePoint(x,y,3.3,2.9,0.3,0.3,time);
   a=a+makePoint(x,y,1.9,2.0,0.4,0.4,time);
   a=a+makePoint(x,y,0.8,0.7,0.4,0.5,time);
   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time);
   a=a+makePoint(x,y,0.8,1.7,0.5,0.4,time);
   a=a+makePoint(x,y,0.3,1.0,0.4,0.4,time);
   a=a+makePoint(x,y,1.4,1.7,0.4,0.5,time);
   a=a+makePoint(x,y,1.3,2.1,0.6,0.3,time);
   a=a+makePoint(x,y,1.8,1.7,0.5,0.4,time);   
   
   float b=
       makePoint(x,y,1.2,1.9,0.3,0.3,time);
   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,time);
   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,time);
   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,time);
   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,time);
   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,time);
   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,time);
   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,time);
   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,time);

   float c=
       makePoint(x,y,3.7,0.3,0.3,0.3,time);
   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,time);
   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,time);
   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,time);
   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,time);
   c=c+makePoint(x,y,0.3,0.3,0.4,0.4,time);
   c=c+makePoint(x,y,1.4,0.8,0.4,0.5,time);
   c=c+makePoint(x,y,0.2,0.6,0.6,0.3,time);
   c=c+makePoint(x,y,1.3,0.5,0.5,0.4,time);
   
   vec3 d=vec3(a,b,c)/32.0;
   
   gl_FragColor = vec4(d.x,d.y,d.z,1.0);
}"
},
{
	"name" : "Plasma Triangle",
	"date" : "29/5/2013",
	"description" : "3 points of a glowing triangle orbit round each other. Sine waves with various coefficients define the orbits. The links are rendered by using dot products to determine how close a given fragment is to the edge of the triangle.",
	"author" : "ElusivePete",
	"authorProfile" : "https://www.shadertoy.com/user/ElusivePete",
	"shaderLink" : "https://www.shadertoy.com/view/XdX3WN",
	"tags" : ["pseudo3d", "additiveblending"],
	"views" : 63,
	"likes" : 4,
	"comments" : [],
	"shaderString" : "

void main(void)
{
	float pointRadius = 0.06;
	float linkSize = 0.04;
	float noiseStrength = 0.08; // range: 0-1
	
	float minDimension = min(iResolution.x, iResolution.y);
	vec2 bounds = vec2(iResolution.x / minDimension, iResolution.y / minDimension);
	vec2 uv = gl_FragCoord.xy / minDimension;
	
	vec3 pointR = vec3(0.0, 0.0, 1.0);
	vec3 pointG = vec3(0.0, 0.0, 1.0);
	vec3 pointB = vec3(0.0, 0.0, 1.0);
	
	// Make the points orbit round the origin in 3 dimensions.
	// Coefficients are arbitrary to give different behaviours.
	// The Z coordinate should always be >0.0, as it's used directly to
	//  multiply the radius to give the impression of depth.
	pointR.x += 0.32 * sin(1.32 * iGlobalTime);
	pointR.y += 0.3 * sin(1.03 * iGlobalTime);
	pointR.z += 0.4 * sin(1.32 * iGlobalTime);
	
	pointG.x += 0.31 * sin(0.92 * iGlobalTime);
	pointG.y += 0.29 * sin(0.99 * iGlobalTime);
	pointG.z += 0.38 * sin(1.24 * iGlobalTime);
	
	pointB.x += 0.33 * sin(1.245 * iGlobalTime);
	pointB.y += 0.3 * sin(1.41 * iGlobalTime);
	pointB.z += 0.41 * sin(1.11 * iGlobalTime);
	
	// Centre the points in the display
	vec2 midUV = vec2(bounds.x * 0.5, bounds.y * 0.5);
	pointR.xy += midUV;
	pointG.xy += midUV;
	pointB.xy += midUV;
	
	// Calculate the vectors from the current fragment to the coloured points
	vec2 vecToR = pointR.xy - uv;
	vec2 vecToG = pointG.xy - uv;
	vec2 vecToB = pointB.xy - uv;
	
	vec2 dirToR = normalize(vecToR.xy);
	vec2 dirToG = normalize(vecToG.xy);
	vec2 dirToB = normalize(vecToB.xy);
	
	float distToR = length(vecToR);
	float distToG = length(vecToG);
	float distToB = length(vecToB);
	
	// Calculate the dot product between vectors from the current fragment to each pair
	//  of adjacent coloured points. This helps us determine how close the current fragment
	//  is to a link between points.
	float dotRG = dot(dirToR, dirToG);
	float dotGB = dot(dirToG, dirToB);
	float dotBR = dot(dirToB, dirToR);
	
	// Start with a bright coloured dot around each point
	gl_FragColor.x = 1.0 - smoothstep(distToR, 0.0, pointRadius * pointR.z);
	gl_FragColor.y = 1.0 - smoothstep(distToG, 0.0, pointRadius * pointG.z);
	gl_FragColor.z = 1.0 - smoothstep(distToB, 0.0, pointRadius * pointB.z);
	gl_FragColor.w = 1.0;	
	
	// We want to show a coloured link between adjacent points.
	// Determine the strength of each link at the current fragment.
	// This tends towards 1.0 as the vectors to each point tend towards opposite directions.
	float linkStrengthRG = 1.0 - smoothstep(dotRG, -1.01, -1.0 + (linkSize * pointR.z * pointG.z));
	float linkStrengthGB = 1.0 - smoothstep(dotGB, -1.01, -1.0 + (linkSize * pointG.z * pointB.z));
	float linkStrengthBR = 1.0 - smoothstep(dotBR, -1.01, -1.0 + (linkSize * pointB.z * pointR.z));
	
	// If the current fragment is in a link, we need to know how much the
	//  linked points contribute of their colour.
	float sumDistRG = distToR + distToG;
	float sumDistGB = distToG + distToB;
	float sumDistBR = distToB + distToR;
	
	float contribRonRG = 1.0 - (distToR / sumDistRG);
	float contribRonBR = 1.0 - (distToR / sumDistBR);
	
	float contribGonRG = 1.0 - (distToG / sumDistRG);
	float contribGonGB = 1.0 - (distToG / sumDistGB);
	
	float contribBonGB = 1.0 - (distToB / sumDistGB);
	float contribBonBR = 1.0 - (distToB / sumDistBR);
	
	// Additively blend the link colours into the fragment.
	gl_FragColor.x += (linkStrengthRG * contribRonRG) + (linkStrengthBR * contribRonBR);
	gl_FragColor.y += (linkStrengthGB * contribGonGB) + (linkStrengthRG * contribGonRG);
	gl_FragColor.z += (linkStrengthBR * contribBonBR) + (linkStrengthGB * contribBonGB);
	
	// Use an underlying texture to provide some noise
	float noiseMin = 1.0 - noiseStrength;
	gl_FragColor.xyz *= (1.0 - noiseStrength) + (noiseStrength * texture2D(iChannel0, uv * 2.0).xyz);
}"
},
{
	"name" : "Voronoi - distances",
	"date" : "22/5/2013",
	"description" : "Mathematically correct Voronoi cell interior distances, and hence correct cell borders. Seems there's nobody out there doing this correctly... So here. More info here: http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm",
	"author" : "iq",
	"authorProfile" : "https://www.shadertoy.com/user/iq",
	"shaderLink" : "https://www.shadertoy.com/view/ldl3W8",
	"tags" : ["2d", "voronoi"],
	"views" : 685,
	"likes" : 7,
	"comments" : [],
	"shaderString" : 
	"// Created by inigo quilez - iq/2013
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// I've not seen anybody out there computing correct cell interior distances for Voronoi
// patterns yet. That's why they cannot shade the cell interior correctly, and why you've
// never seen cell boundaries rendered correctly. 
//
// However, here's how you do mathematically correct distances (note the equidistant and non
// degenerated grey isolines inside the cells) and hence edges (in yellow):
//
// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm


#define ANIMATE

float hash( float n )
{
    return fract(sin(n)*43758.5453);
}

vec2 hash( vec2 p )
{
    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
	return fract(sin(p)*43758.5453);
}

vec3 voronoi( in vec2 x )
{
    vec2 n = floor(x);
    vec2 f = fract(x);

    //----------------------------------
    // first pass: regular voronoi
    //----------------------------------
	vec2 mg, mr;

    float md = 8.0;
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ )
    {
        vec2 g = vec2(float(i),float(j));
		vec2 o = hash( n + g );
		#ifdef ANIMATE
        o = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );
        #endif	
        vec2 r = g + o - f;
        float d = dot(r,r);

        if( d<md )
        {
            md = d;
            mr = r;
            mg = g;
        }
    }

    //----------------------------------
    // second pass: distance to borders
    //----------------------------------
    md = 8.0;
    for( int j=-2; j<=2; j++ )
    for( int i=-2; i<=2; i++ )
    {
        vec2 g = mg + vec2(float(i),float(j));
		vec2 o = hash( n + g );
		#ifdef ANIMATE
        o = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );
        #endif	
        vec2 r = g + o - f;

        if( length(mr-r)<0.0001 ) continue;

        // distance to line		
        float d = dot( 0.5*(mr+r), normalize(r-mr) );

        md = min( md, d );
    }

    return vec3( md, mr );
}

void main( void )
{
    vec2 p = gl_FragCoord.xy/iResolution.xx;

    vec3 c = voronoi( 8.0*p );

	// isolines
    vec3 col = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);
    // borders	
    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );
    // feature points
	float dd = length( c.yz );
	col = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );
	col += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));

	gl_FragColor = vec4(col,1.0);
}"
},
{
	"name" : "Waves",
	"date" : "3/6/2013",
	"description" : "A simple live wallpaper :)",
	"author" : "bonniem",
	"authorProfile" : "https://www.shadertoy.com/user/bonniem",
	"shaderLink" : "https://www.shadertoy.com/view/4dsGzH",
	"tags" : ["2d", "waves"],
	"views" : 373,
	"likes" : 1,
	"comments" : [],
	"shaderString" : "vec3 COLOR1 = vec3(0.0, 0.0, 0.3);
vec3 COLOR2 = vec3(0.5, 0.0, 0.0);
float BLOCK_WIDTH = 0.01;

void main(void)
{
	vec2 uv = gl_FragCoord.xy / iResolution.xy;
	
	// To create the BG pattern
	vec3 final_color = vec3(1.0);
	vec3 bg_color = vec3(0.0);
	vec3 wave_color = vec3(0.0);
	
	float c1 = mod(uv.x, 2.0 * BLOCK_WIDTH);
	c1 = step(BLOCK_WIDTH, c1);
	
	float c2 = mod(uv.y, 2.0 * BLOCK_WIDTH);
	c2 = step(BLOCK_WIDTH, c2);
	
	bg_color = mix(uv.x * COLOR1, uv.y * COLOR2, c1 * c2);
	
	
	// To create the waves
	float wave_width = 0.01;
	uv  = -1.0 + 2.0 * uv;
	uv.y += 0.1;
	for(float i = 0.0; i < 10.0; i++) {
		
		uv.y += (0.07 * sin(uv.x + i/7.0 + iGlobalTime ));
		wave_width = abs(1.0 / (150.0 * uv.y));
		wave_color += vec3(wave_width * 1.9, wave_width, wave_width * 1.5);
	}
	
	final_color = bg_color + wave_color;
	
	
	gl_FragColor = vec4(final_color, 1.0);
}"
},
{
	"name" : "Dancing pixels",
	"date" : "27/4/2013",
	"description" : "ok first experiment on shadertoy, used algorithm is \"sine puke\" from WAHa_06x36",
	"author" : "sharavsambuu",
	"authorProfile" : "https://www.shadertoy.com/user/sharavsambuu",
	"shaderLink" : "https://www.shadertoy.com/view/ldX3Wn",
	"tags" : ["2d"],
	"views" : 132,
	"likes" : 5,
	"comments" : [],
	"shaderString" : "const float Pi = 3.14159;
float beat = 0.;

void main(void)
{
	float ct = iGlobalTime;//iChannelTime[0];
	if ((ct > 8.0 && ct < 33.5)
	|| (ct > 38.0 && ct < 88.5)
	|| (ct > 93.0 && ct < 194.5))
		beat = pow(sin(ct*3.1416*3.78+1.9)*0.5+0.5,15.0)*0.1;
	
	vec2 uv = gl_FragCoord.xy / iResolution.xy;
	vec2 p=(2.0*gl_FragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);
	
	for(int i=1;i<40;i++)
	{
		vec2 newp=p;
		newp.x+=0.5/float(i)*cos(float(i)*p.y+beat+iGlobalTime*cos(ct)*0.3/40.0+0.03*float(i))+10.0;		
		newp.y+=0.5/float(i)*cos(float(i)*p.x+beat+iGlobalTime*ct*0.3/50.0+0.03*float(i+10))+15.0;
		p=newp;
	}
	
	vec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(p.x+p.y));
	//col -= mod( gl_FragCoord.y, 2.0 ) < 1.0 ? 0.5 : 0.0;
	gl_FragColor=vec4(col, 1.0);
	
}"
}]